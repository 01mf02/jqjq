# Test case format is the same as jq --run-tests uses
#
# Format:
# filter expression line
# input JSON line
# zero or more output JSON lines

# null
null
null
null

# number
123, 1.23, 0.123, .123, .123e1, 1.23e1, 2E3
null
123
1.23
0.123
0.123
1.23
12.3
2000

# string
"abc"
null
"abc"

"escape \"\n\r\\ literal"
null
"escape \"\n\r\\ literal"
# TODO: invalid escape

# array literal
[]
null
[]

[1,2,3]
null
[1,2,3]

[1,.,empty,3]
2
[1,2,3]

# object literal
{}
null
{}

{a: 1}
null
{"a": 1}

{a}
{"a": 1}
{"a": 1}

{"a"}
{"a": 1}
{"a": 1}

1 as $a | {$a}
null
{"a": 1}

{("a"+"b"): 1}
null
{"ab": 1}

{a: 1, b: 2} | 3 as $c | {a, "b", $c, ("d"): 4}
null
{"a": 1, "b": 2, "c": 3, "d": 4}

# empty key or value means empty output
{a: empty}
null

{(empty): 1}
null

{a: 1, b: empty}
null

{a: 1, b: {c: empty}}
null

{("a","b"): (1,2)}
null
{"a":1}
{"a":2}
{"b":1}
{"b":2}

{a: 1, ("b","c"): (2,3), d: 4}
null
{"a":1,"b":2,"d":4}
{"a":1,"b":3,"d":4}
{"a":1,"c":2,"d":4}
{"a":1,"c":3,"d":4}

{a:"aa",b:"bb",c:3,d:4} | {(.a,.b): (.c,.d)}
null
{"aa":3}
{"aa":4}
{"bb":3}
{"bb":4}

# object val allows | but no other operator
{a: 123 | -., b: 4}
null
{"a":-123,"b":4}

# binding
. as $a | $a
123
123

. as $a | .+$a as $c | $c
123
246

# valid names
1 as $_ | $_ | 2 as $__ | 3 as $_abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_ | $_, $__, $_abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_
null
1
2
3

def _: 1; def __: 2; def _abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_: 3; _, __, _abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_
null
1
2
3

1 as $_ | $_
null
1

# comma
1,2,3
null
1
2
3

# pipe
1 | .*2
null
2

# empty
empty
null

# identity
.*.*2
2
8

# if
.[] | if . == 1 then "a" end
[1,2]
"a"
2

.[] | if . == 1 then "a" else "b" end
[1,2]
"a"
"b"

.[] | if . == 1 then "a" elif . == 2 then "b" elif . == 3 then "c" else "d" end
[1,2,3,4]
"a"
"b"
"c"
"d"

# zero or more cond outputs
4 | if true,false,true then 1 elif true,false then 2 elif true,false then 3 else . end
null
1
2
3
4
1

2 | if true,empty,true then 1 else . end
null
1
1

2 | if empty then 1 else . end
null

if empty then 1 end
null

if true,true then 1 end
null
1
1

# comparisons
0 == 0, 0 == 1, 1 == 0
null
true
false
false

0 != 0, 0 != 1, 1 != 0
null
false
true
true

0 < 0, 0 < 1, 1 < 0
null
false
true
false

0 <= 0, 0 <= 1, 1 <= 0
null
true
true
false

0 > 0, 0 > 1, 1 > 0
null
false
false
true

0 >= 0, 0 >= 1, 1 >= 0
null
true
false
true

# unary operators
# + not supported by jq?
-1, -(2,3)
null
-1
-2
-3

-(-.)
-123
-123

-(-123)
null
123

# logical operators
true and true, true and false, false and true, false and false
null
true
false
false
false

(true,false) and (true,false)
null
true
false
false

true or true, true or false, false or true, false or false
null
true
true
true
false

(true,false) or (true,false)
null
true
true
false

# arithmetic operators
. + 3
10
13

. - 3
10
7

. * 3
10
30

. / 3
10
3.3333333333333335

. % 3
10
1

# functions
def f: 123; f
null
123

def f: .; f
123
123

def f(a): a; f(.*2)
123
246

def f($a): .+$a; f(1,2,3)
1
2
3
4

def f(a): a; f(empty)
null

def f($a): $a; f(empty)
null

# $a is available as a lambda also
def f($a): a | [$a, .]; f(1,2)
null
[1,1]
[1,2]
[2,1]
[2,2]

def f($a; $b; c): [., $a, $b, (.+$a+$b | c)]; f(1,2,3; 10,20; .*2)
100
[100,1,10,222]
[100,1,20,242]
[100,2,10,224]
[100,2,20,244]
[100,3,10,226]
[100,3,20,246]

def a: 20; . + a  + def b: 3; b
100
123

def f: 123; f + f
null
246

# scoping (lexical, can only refer to previous and can't change)
def a: 1; def b: a; def a: 3; b
null
1

# function and lambda arg same name
# TODO: explain lambda not recursive
def f(a): a; def a: 123; f(a)
null
123

def f(f): f; f(123)
null
123

# recursive
def f: if . >= 0 then ., (.-1 | f) else empty end; f
2
2
1
0

# builtins

[], [1,2,3] | map(.*2)
null
[]
[2,4,6]

[1,2] | map(., 10)
null
[1,10,2,10]

1,2,3 | select(. == 2)
null
2

# precedence
# TODO: add more
1+2+3*4*5-6-7/8/9,.|.
null
56.90277777777778
null

# assign
.a = 123
null
{"a":123}

(.a,.b) = 123
null
{"a":123,"b":123}

# update |=
.a = 123 | .a |= . + 1
null
{"a":124}

.a = 123 | (.a,.b) |= . + 3
null
{"a":126,"b":3}

# update +=

.a = 123 | .a += 3
null
{"a":126}

.a = 123 | (.a,.b) += 3
null
{"a":126,"b":3}

# += etc rhs gets lhs input as input, different from |= where rhs get output as lhs as input
.a = 3 | .a += .a + 3
null
{"a":9}

# update -=

.a = 123 | .a -= 3
null
{"a":120}

.a = 123 | .b = 0 | (.a,.b) -= 3
null
{"a":120,"b":-3}

# update *=

.a = 123 | .a *= 3
null
{"a":369}

.a = 123 | .b = 1 | (.a,.b) *= 3
null
{"a":369,"b":3}

# update /=

.a = 120 | .a /= 3
null
{"a":40}

.a = 120 | .b = 3 | (.a,.b) /= 3
null
{"a":40,"b":1}

# update %=

.a = 123 | .a %= 4
null
{"a":3}

.a = 123 | .b = 4 | (.a,.b) %= 4
null
{"a":3,"b":0}

# reduce
reduce (.,2,3) as $v (.; . + $v)
1
7

reduce empty as $v (123; .)
null
123

# foreach
foreach (.,2,3) as $v (.; . + $v)
1
2
4
7

foreach (.,2,3) as $v (.; . + $v; . * 2)
1
4
8
14

foreach empty as $v (123; .)
null

# array slice
.[0:], .[1:], .[1:-1], .[1:-2], .[-2:], .[-1:]
[1,2,3,4]
[1,2,3,4]
[2,3,4]
[2,3]
[2]
[3,4]
[4]

.[:0], .[:1], .[:4], .[-2:], .[-1:], .[1:3], .[1:-2]
[1,2,3,4]
[]
[1]
[1,2,3,4]
[3,4]
[4]
[2,3]
[2]

# tests def and "," associativity
# test from jq's jq.test
def f: 1; def g: f, def f: 2; def g: 3; f, def f: g; f, g; def f: 4; [f, def f: g; def g: 5; f, g]+[f,g]
null
[4,1,2,3,3,5,4,1,2,3,3]

# try/catch/error
try .
123
123

try . catch 456
123
123

try error(.)
123

try error(.) catch .
123
123

try (1+"a") catch .
null
"number (1) and string (\"a\") cannot be added"

# standard library
map(add)
[[], [1], [1,2,3]]
[null,1,6]

map(not)
[null,false,true,1]
[true,true,false,false]

select(false)
null

map(select(. != 1))
[0,1,2]
[0,2]

map(.,.), map(.), map(empty)
[1,2]
[1,1,2,2]
[1,2]
[]

map(min)
[[],[1],[3,1,2]]
[null,1,1]

map(max)
[[],[1],[2,3,1]]
[null,1,3]

map([range(.[0]; .[1]; .[2])])
[[0,0,0],[-10,0,2],[0,-10,-2],[0,10,3],[10,0,3]]
[[],[-10,-8,-6,-4,-2],[0,-2,-4,-6,-8],[0,3,6,9],[]]

map([range(.[0]; .[1])])
[[-2,0],[0,-2],[0,2],[2,0]]
[[-2,-1],[],[0,1],[]]

map([range(.)])
[-1,0,1,2]
[[],[],[0],[0,1]]

map(reverse)
[[],[1],[1,2,3]]
[[],[1],[3,2,1]]

[recurse], [..]
{"a":[1,2,3]}
[{"a":[1,2,3]},[1,2,3],1,2,3]
[{"a":[1,2,3]},[1,2,3],1,2,3]

[recurse(if length == 0 then empty else .[1:] end)]
[1,2,3]
[[1,2,3],[2,3],[3],[]]

map(sort)
[[],[1],[3,2],[3,1,2]]
[[],[1],[2,3],[1,2,3]]

map(sort)
[[],[{"a":1}],[{"a":3},{"a":2}],[{"a":3},{"a":1},{"a":2}]]
[[],[{"a":1}],[{"a":2},{"a":3}],[{"a":1},{"a":2},{"a":3}]]

# SKIP_JQ
# test below does not work with standard jq because of missing features or bugs

# elif mixed with optional else
# if
.[] | if . == 1 then "a" elif . == 2 then "b" end
[1,2,3]
"a"
"b"
3

.[] | if . == 1 then "a" elif . == 2 then "b" elif . == 3 then "c" end
[1,2,3,4]
"a"
"b"
"c"
4

# unary plus operator
+123
null
123

+1, +(2,3)
null
1
2
3

+(+.)
123
123

# binding with same name as keyword
. as $if | $if
123
123

